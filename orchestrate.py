#!/usr/bin/env python3
"""
Orchestration script to manage multiple Docker Compose instances for parallel data collection.
"""

import argparse
import os
import subprocess
import sys
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Dict, List, Optional

import signal
import yaml
import shutil


class LogManager:
    def __init__(self, base_dir: Path, compose_bin: Optional[List[str]] = None):
        self.base_dir = base_dir
        self.base_dir.mkdir(parents=True, exist_ok=True)
        self.compose_bin = compose_bin or ["docker", "compose"]

    def start_for_instance(
        self,
        compose_file: Path,
        project: str,
        services: List[str],
    ) -> Dict[str, subprocess.Popen]:
        """Start background log capture for the given services.

        Returns a mapping of service -> Popen handle.
        """
        logs_dir = self.base_dir / project
        logs_dir.mkdir(parents=True, exist_ok=True)
        processes: Dict[str, subprocess.Popen] = {}
        for service in services:
            logfile = logs_dir / f"{service}.log"
            # Open file handle in text mode; let Popen own it
            fhandle = open(logfile, "w")
            cmd = [
                *self.compose_bin,
                "-p",
                project,
                "-f",
                str(compose_file),
                "logs",
                "--no-color",
                "--timestamps",
                "--follow",
                service,
            ]
            try:
                proc = subprocess.Popen(cmd, stdout=fhandle, stderr=subprocess.STDOUT)
                processes[service] = proc
            except Exception:
                try:
                    fhandle.close()
                except Exception:  # pragma: no cover
                    pass
        return processes

    def stop_for_instance(self, processes: Dict[str, subprocess.Popen]) -> None:
        for svc, proc in processes.items():
            try:
                if proc.poll() is None:
                    proc.terminate()
                    try:
                        proc.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        proc.kill()
            except Exception:
                continue


def detect_compose_bin() -> List[str]:
    """Detect docker compose binary preference.

    Prefer 'docker compose' if available, otherwise fallback to 'docker-compose'.
    """
    try:
        res = subprocess.run(["docker", "compose", "version"], capture_output=True)
        if res.returncode == 0:
            return ["docker", "compose"]
    except Exception:
        pass
    if shutil.which("docker-compose"):
        return ["docker-compose"]
    # Fallback to docker compose
    return ["docker", "compose"]


class InstanceManager:
    def __init__(self, compose_dir="compose_configs"):
        self.compose_dir = Path(compose_dir)
        self.running_instances = {}
        self.compose_bin = detect_compose_bin()
        self.log_manager = LogManager(Path("logs"), self.compose_bin)
        # service base names as generated by generate_compose.py
        self.service_bases = [
            "mc_instance_{i}",
            "sender_alpha_instance_{i}",
            "sender_bravo_instance_{i}",
            "receiver_alpha_instance_{i}",
            "receiver_bravo_instance_{i}",
            "camera_alpha_instance_{i}",
            "camera_alpha_follow_instance_{i}",
            "camera_bravo_instance_{i}",
            "camera_bravo_follow_instance_{i}",
        ]
        self.instance_logs: Dict[str, Dict[str, subprocess.Popen]] = {}

    def get_compose_files(self):
        """Get all Docker Compose files in the config directory."""
        return sorted(list(self.compose_dir.glob("docker-compose-*.yml")))

    def start_instance(self, compose_file):
        """Start a single Docker Compose instance."""
        instance_name = compose_file.stem
        print(f"Starting instance: {instance_name}")

        try:
            cmd = [
                *self.compose_bin,
                "-p",
                instance_name,
                "-f",
                str(compose_file),
                "up",
                "-d",
            ]
            result = subprocess.run(
                cmd, capture_output=True, text=True, cwd=self.compose_dir.parent
            )

            if result.returncode == 0:
                print(f"âœ… Started: {instance_name}")
                # Begin per-service log capture
                idx = self._instance_index_from_stem(instance_name)
                services = [s.format(i=idx) for s in self.service_bases]
                self.instance_logs[instance_name] = self.log_manager.start_for_instance(
                    compose_file, instance_name, services
                )
                # Print VNC/noVNC URLs
                self._print_vnc_urls(compose_file, instance_name)
                return True, instance_name
            else:
                print(f"âŒ Failed to start {instance_name}: {result.stderr}")
                return False, instance_name

        except Exception as e:
            print(f"âŒ Error starting {instance_name}: {e}")
            return False, instance_name

    def stop_instance(self, compose_file):
        """Stop a single Docker Compose instance."""
        instance_name = compose_file.stem
        print(f"Stopping instance: {instance_name}")

        try:
            # Stop log capture first
            self.log_manager.stop_for_instance(self.instance_logs.pop(instance_name, {}))
            cmd = [
                *self.compose_bin,
                "-p",
                instance_name,
                "-f",
                str(compose_file),
                "down",
                "-v",
            ]
            result = subprocess.run(
                cmd, capture_output=True, text=True, cwd=self.compose_dir.parent
            )

            if result.returncode == 0:
                print(f"âœ… Stopped: {instance_name}")
                return True, instance_name
            else:
                print(f"âŒ Failed to stop {instance_name}: {result.stderr}")
                return False, instance_name

        except Exception as e:
            print(f"âŒ Error stopping {instance_name}: {e}")
            return False, instance_name

    def start_all(self):
        """Start all instances in parallel."""
        compose_files = self.get_compose_files()
        total_instances = len(compose_files)

        if total_instances == 0:
            print("No Docker Compose files found. Run generate_compose.py first.")
            return

        print(f"Starting {total_instances} instances in parallel...")

        # Start all instances simultaneously
        with ThreadPoolExecutor(max_workers=total_instances) as executor:
            futures = {
                executor.submit(self.start_instance, cf): cf for cf in compose_files
            }

            for future in as_completed(futures):
                success, instance_name = future.result()
                if success:
                    self.running_instances[instance_name] = futures[future]

        print(
            f"\nðŸŽ‰ Started {len(self.running_instances)}/{total_instances} instances successfully"
        )

    def stop_all(self):
        """Stop all instances."""
        compose_files = self.get_compose_files()
        total_instances = len(compose_files)

        if total_instances == 0:
            print("No Docker Compose files found.")
            return

        print(f"Stopping {total_instances} instances...")

        with ThreadPoolExecutor(max_workers=total_instances) as executor:
            futures = {
                executor.submit(self.stop_instance, cf): cf for cf in compose_files
            }

            stopped_count = 0
            for future in as_completed(futures):
                success, instance_name = future.result()
                if success:
                    stopped_count += 1

        print(f"\nðŸ›‘ Stopped {stopped_count}/{total_instances} instances")

    def status(self):
        """Show status of all instances."""
        compose_files = self.get_compose_files()

        if not compose_files:
            print("No Docker Compose files found.")
            return

        print(f"Found {len(compose_files)} configured instances:")
        print("\nChecking status...")

        running_count = 0
        for compose_file in compose_files:
            instance_name = compose_file.stem
            try:
                cmd = [
                    "docker",
                    "compose",
                    "-p",
                    instance_name,
                    "-f",
                    str(compose_file),
                    "ps",
                    "-q",
                ]
                result = subprocess.run(
                    cmd, capture_output=True, text=True, cwd=self.compose_dir.parent
                )

                if result.stdout.strip():
                    # Check if containers are actually running
                    container_ids = result.stdout.strip().split("\n")
                    container_ids = [
                        cid for cid in container_ids if cid.strip()
                    ]  # Filter empty strings

                    running_containers = 0
                    for container_id in container_ids:
                        inspect_cmd = [
                            "docker",
                            "inspect",
                            "--format",
                            "{{.State.Status}}",
                            container_id,
                        ]
                        inspect_result = subprocess.run(
                            inspect_cmd, capture_output=True, text=True
                        )
                        if inspect_result.stdout.strip() == "running":
                            running_containers += 1

                    if running_containers > 0:
                        print(
                            f"ðŸŸ¢ {instance_name}: {running_containers} containers running"
                        )
                        running_count += 1
                    else:
                        print(f"ðŸŸ¡ {instance_name}: containers exist but not running")
                else:
                    print(f"ðŸ”´ {instance_name}: stopped")

            except Exception as e:
                print(f"â“ {instance_name}: error checking status - {e}")

        print(f"\nSummary: {running_count}/{len(compose_files)} instances running")

    def logs(self, instance_pattern=None, follow=False, tail: int = 50):
        """Tail saved log files captured by LogManager.

        If no saved logs exist yet, fallback to docker compose logs.
        """
        logs_root = Path("logs")
        instances = []
        if instance_pattern:
            for p in logs_root.glob(f"*{instance_pattern}*"):
                if p.is_dir():
                    instances.append(p)
        else:
            instances = [p for p in logs_root.iterdir() if p.is_dir()]

        if not instances:
            # Fallback behavior
            print("No saved logs found; falling back to docker compose logs")
            compose_files = self.get_compose_files()
            if instance_pattern:
                compose_files = [cf for cf in compose_files if instance_pattern in cf.stem]
            for compose_file in compose_files:
                cmd = [
                    *self.compose_bin,
                    "-p",
                    compose_file.stem,
                    "-f",
                    str(compose_file),
                    "logs",
                    "--tail",
                    "50",
                ]
                subprocess.run(cmd, cwd=self.compose_dir.parent)
            return

        for inst_dir in instances:
            print(f"\n{'='*50}")
            print(f"Saved logs for {inst_dir.name}")
            print(f"{'='*50}")
            for logf in sorted(inst_dir.glob("*.log")):
                print(f"-- {logf.name} (last {tail} lines) --")
                try:
                    with open(logf, "r", encoding="utf-8", errors="ignore") as fh:
                        lines = fh.readlines()
                        for line in lines[-tail:]:
                            sys.stdout.write(line)
                except Exception as e:
                    print(f"failed to read {logf}: {e}")

    def _instance_index_from_stem(self, stem: str) -> int:
        # Expect docker-compose-XYZ
        try:
            idx = int(stem.split("-")[-1])
            return idx
        except Exception:
            return 0

    def _print_vnc_urls(self, compose_file: Path, instance_name: str) -> None:
        try:
            with open(compose_file, "r", encoding="utf-8") as fh:
                data = yaml.safe_load(fh)
            # try to locate env NOVNC_PORT for alpha/bravo
            ports = {}
            for svc_name, svc in (data.get("services") or {}).items():
                env = svc.get("environment") or {}
                if svc_name.startswith("camera_alpha_instance_") and "NOVNC_PORT" in env:
                    ports["alpha"] = str(env["NOVNC_PORT"]).strip()
                if svc_name.startswith("camera_bravo_instance_") and "NOVNC_PORT" in env:
                    ports["bravo"] = str(env["NOVNC_PORT"]).strip()
            if ports:
                a = ports.get("alpha")
                b = ports.get("bravo")
                if a:
                    print(f"[orchestrate] {instance_name} noVNC alpha: http://localhost:{a}")
                if b:
                    print(f"[orchestrate] {instance_name} noVNC bravo: http://localhost:{b}")
        except Exception:
            return

    def recordings(self) -> None:
        root = Path.cwd()
        alpha_root = root / "camera" / "output_alpha"
        bravo_root = root / "camera" / "output_bravo"
        print("[orchestrate] camera recordings (alpha):")
        if alpha_root.exists():
            for p in sorted(alpha_root.rglob("camera_*.mp4")):
                print(f"  {p}")
        else:
            print("  (none)")
        print("[orchestrate] camera recordings (bravo):")
        if bravo_root.exists():
            for p in sorted(bravo_root.rglob("camera_*.mp4")):
                print(f"  {p}")
        else:
            print("  (none)")


def main():
    parser = argparse.ArgumentParser(
        description="Orchestrate multiple Docker Compose instances"
    )
    parser.add_argument(
        "command",
        choices=["start", "stop", "status", "logs", "recordings"],
        help="Command to execute",
    )
    parser.add_argument(
        "--compose-dir",
        default="compose_configs",
        help="Directory containing Docker Compose files",
    )
    parser.add_argument("--instance", help="Instance pattern for logs command")
    parser.add_argument(
        "--follow",
        "-f",
        action="store_true",
        help="Follow logs (only for single instance)",
    )
    parser.add_argument(
        "--tail",
        type=int,
        default=50,
        help="Tail last N lines when showing saved logs (default: 50)",
    )

    args = parser.parse_args()

    manager = InstanceManager(args.compose_dir)

    if args.command == "start":
        manager.start_all()
    elif args.command == "stop":
        manager.stop_all()
    elif args.command == "status":
        manager.status()
    elif args.command == "logs":
        manager.logs(args.instance, args.follow, args.tail)
    elif args.command == "recordings":
        manager.recordings()


if __name__ == "__main__":
    main()
